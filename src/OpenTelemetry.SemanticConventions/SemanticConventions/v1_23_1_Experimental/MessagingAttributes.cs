// <copyright file="MessagingAttributes.cs" company="OpenTelemetry Authors">
// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// </copyright>

// <auto-generated> This file has been auto generated from buildscripts/semantic-conventions/templates/Attributes.cs.j2</auto-generated>

using System;

namespace OpenTelemetry.SemanticConventions.v1_23_1_Experimental
{
    /// <summary>
    /// Describes semantic conventions for attributes in the <c>messaging</c> namespace.
    /// </summary>
    public static class MessagingAttributes
    {
        /// <summary>
        /// The number of messages sent, received, or processed in the scope of the batching operation.
        /// </summary>
        /// <remarks>
        /// Instrumentations SHOULD NOT set <c>messaging.batch.message_count</c> on spans that operate with a single message. When a messaging client library supports both batch and single-message API for the same operation, instrumentations SHOULD use <c>messaging.batch.message_count</c> for batching APIs and SHOULD NOT use it for single-message APIs.
        /// </remarks>
        public const string MessagingBatchMessageCount = "messaging.batch.message_count";

        /// <summary>
        /// A unique identifier for the client that consumes or produces a message.
        /// </summary>
        public const string MessagingClientId = "messaging.client_id";

        /// <summary>
        /// A boolean that is true if the message destination is anonymous (could be unnamed or have auto-generated name).
        /// </summary>
        public const string MessagingDestinationAnonymous = "messaging.destination.anonymous";

        /// <summary>
        /// The message destination name.
        /// </summary>
        /// <remarks>
        /// Destination name SHOULD uniquely identify a specific queue, topic or other entity within the broker. If
        /// the broker doesn&amp;#39;t have such notion, the destination name SHOULD uniquely identify the broker.
        /// </remarks>
        public const string MessagingDestinationName = "messaging.destination.name";

        /// <summary>
        /// Low cardinality representation of the messaging destination name.
        /// </summary>
        /// <remarks>
        /// Destination names could be constructed from templates. An example would be a destination name involving a user name or product id. Although the destination name in this case is of high cardinality, the underlying template is of low cardinality and can be effectively used for grouping and aggregation.
        /// </remarks>
        public const string MessagingDestinationTemplate = "messaging.destination.template";

        /// <summary>
        /// A boolean that is true if the message destination is temporary and might not exist anymore after messages are processed.
        /// </summary>
        public const string MessagingDestinationTemporary = "messaging.destination.temporary";

        /// <summary>
        /// A boolean that is true if the publish message destination is anonymous (could be unnamed or have auto-generated name).
        /// </summary>
        public const string MessagingDestinationPublishAnonymous = "messaging.destination_publish.anonymous";

        /// <summary>
        /// The name of the original destination the message was published to.
        /// </summary>
        /// <remarks>
        /// The name SHOULD uniquely identify a specific queue, topic, or other entity within the broker. If
        /// the broker doesn&amp;#39;t have such notion, the original destination name SHOULD uniquely identify the broker.
        /// </remarks>
        public const string MessagingDestinationPublishName = "messaging.destination_publish.name";

        /// <summary>
        /// Name of the Kafka Consumer Group that is handling the message. Only applies to consumers, not producers.
        /// </summary>
        public const string MessagingKafkaConsumerGroup = "messaging.kafka.consumer.group";

        /// <summary>
        /// Partition the message is sent to.
        /// </summary>
        public const string MessagingKafkaDestinationPartition = "messaging.kafka.destination.partition";

        /// <summary>
        /// Message keys in Kafka are used for grouping alike messages to ensure they're processed on the same partition. They differ from <c>messaging.message.id</c> in that they're not unique. If the key is <c>null</c>, the attribute MUST NOT be set.
        /// </summary>
        /// <remarks>
        /// If the key type is not string, it&amp;#39;s string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don&amp;#39;t include its value.
        /// </remarks>
        public const string MessagingKafkaMessageKey = "messaging.kafka.message.key";

        /// <summary>
        /// The offset of a record in the corresponding Kafka partition.
        /// </summary>
        public const string MessagingKafkaMessageOffset = "messaging.kafka.message.offset";

        /// <summary>
        /// A boolean that is true if the message is a tombstone.
        /// </summary>
        public const string MessagingKafkaMessageTombstone = "messaging.kafka.message.tombstone";

        /// <summary>
        /// The size of the message body in bytes.
        /// </summary>
        /// <remarks>
        /// This can refer to both the compressed or uncompressed body size. If both sizes are known, the uncompressed
        /// body size should be used.
        /// </remarks>
        public const string MessagingMessageBodySize = "messaging.message.body.size";

        /// <summary>
        /// The conversation ID identifying the conversation to which the message belongs, represented as a string. Sometimes called &quot;Correlation ID&quot;.
        /// </summary>
        public const string MessagingMessageConversationId = "messaging.message.conversation_id";

        /// <summary>
        /// The size of the message body and metadata in bytes.
        /// </summary>
        /// <remarks>
        /// This can refer to both the compressed or uncompressed size. If both sizes are known, the uncompressed
        /// size should be used.
        /// </remarks>
        public const string MessagingMessageEnvelopeSize = "messaging.message.envelope.size";

        /// <summary>
        /// A value used by the messaging system as an identifier for the message, represented as a string.
        /// </summary>
        public const string MessagingMessageId = "messaging.message.id";

        /// <summary>
        /// A string identifying the kind of messaging operation.
        /// </summary>
        /// <remarks>
        /// If a custom value is used, it MUST be of low cardinality.
        /// </remarks>
        public const string MessagingOperation = "messaging.operation";

        /// <summary>
        /// RabbitMQ message routing key.
        /// </summary>
        public const string MessagingRabbitmqDestinationRoutingKey = "messaging.rabbitmq.destination.routing_key";

        /// <summary>
        /// Name of the RocketMQ producer/consumer group that is handling the message. The client type is identified by the SpanKind.
        /// </summary>
        public const string MessagingRocketmqClientGroup = "messaging.rocketmq.client_group";

        /// <summary>
        /// Model of message consumption. This only applies to consumer spans.
        /// </summary>
        public const string MessagingRocketmqConsumptionModel = "messaging.rocketmq.consumption_model";

        /// <summary>
        /// The delay time level for delay message, which determines the message delay time.
        /// </summary>
        public const string MessagingRocketmqMessageDelayTimeLevel = "messaging.rocketmq.message.delay_time_level";

        /// <summary>
        /// The timestamp in milliseconds that the delay message is expected to be delivered to consumer.
        /// </summary>
        public const string MessagingRocketmqMessageDeliveryTimestamp = "messaging.rocketmq.message.delivery_timestamp";

        /// <summary>
        /// It is essential for FIFO message. Messages that belong to the same message group are always processed one by one within the same consumer group.
        /// </summary>
        public const string MessagingRocketmqMessageGroup = "messaging.rocketmq.message.group";

        /// <summary>
        /// Key(s) of message, another way to mark message besides message id.
        /// </summary>
        public const string MessagingRocketmqMessageKeys = "messaging.rocketmq.message.keys";

        /// <summary>
        /// The secondary classifier of message besides topic.
        /// </summary>
        public const string MessagingRocketmqMessageTag = "messaging.rocketmq.message.tag";

        /// <summary>
        /// Type of message.
        /// </summary>
        public const string MessagingRocketmqMessageType = "messaging.rocketmq.message.type";

        /// <summary>
        /// Namespace of RocketMQ resources, resources in different namespaces are individual.
        /// </summary>
        public const string MessagingRocketmqNamespace = "messaging.rocketmq.namespace";

        /// <summary>
        /// A string identifying the messaging system.
        /// </summary>
        public const string MessagingSystem = "messaging.system";

        /// <summary>
        /// A string identifying the kind of messaging operation.
        /// </summary>
        public static class MessagingOperationValues
        {
            /// <summary>
            /// One or more messages are provided for publishing to an intermediary. If a single message is published, the context of the &quot;Publish&quot; span can be used as the creation context and no &quot;Create&quot; span needs to be created.
            /// </summary>
            public const string Publish = "publish";
            /// <summary>
            /// A message is created. &quot;Create&quot; spans always refer to a single message and are used to provide a unique creation context for messages in batch publishing scenarios.
            /// </summary>
            public const string Create = "create";
            /// <summary>
            /// One or more messages are requested by a consumer. This operation refers to pull-based scenarios, where consumers explicitly call methods of messaging SDKs to receive messages.
            /// </summary>
            public const string Receive = "receive";
            /// <summary>
            /// One or more messages are passed to a consumer. This operation refers to push-based scenarios, where consumer register callbacks which get called by messaging SDKs.
            /// </summary>
            public const string Deliver = "deliver";
        }

        /// <summary>
        /// Model of message consumption. This only applies to consumer spans.
        /// </summary>
        public static class MessagingRocketmqConsumptionModelValues
        {
            /// <summary>
            /// Clustering consumption model.
            /// </summary>
            public const string Clustering = "clustering";
            /// <summary>
            /// Broadcasting consumption model.
            /// </summary>
            public const string Broadcasting = "broadcasting";
        }

        /// <summary>
        /// Type of message.
        /// </summary>
        public static class MessagingRocketmqMessageTypeValues
        {
            /// <summary>
            /// Normal message.
            /// </summary>
            public const string Normal = "normal";
            /// <summary>
            /// FIFO message.
            /// </summary>
            public const string Fifo = "fifo";
            /// <summary>
            /// Delay message.
            /// </summary>
            public const string Delay = "delay";
            /// <summary>
            /// Transaction message.
            /// </summary>
            public const string Transaction = "transaction";
        }
    }
}