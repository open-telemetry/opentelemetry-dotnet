// <copyright file="SystemMetrics.cs" company="OpenTelemetry Authors">
// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// </copyright>

// <auto-generated> This file has been auto generated from buildscripts/semantic-conventions/templates/Metrics.cs.j2</auto-generated>

using System.Diagnostics.Metrics;

namespace OpenTelemetry.SemanticConventions.v1_23_1_Experimental
{
  /// <summary>
  /// Describes semantic conventions for metrics in the <c>system</c> namespace.
  /// </summary>
  public static class SystemMetrics {
      /// <summary>
      /// Creates <c>system.cpu.frequency</c> instrument.
      /// Reports the current frequency of the CPU in Hz.
      /// </summary>
      public static ObservableGauge<double> CreateSystemCpuFrequency(Meter meter, Func<Measurement<double>> observe)
      {
          return meter.CreateObservableGauge<double>("system.cpu.frequency", observe, "{Hz}", "Reports the current frequency of the CPU in Hz");
      }

      /// <summary>
      /// Creates <c>system.cpu.logical.count</c> instrument.
      /// Reports the number of logical (virtual) processor cores created by the operating system to manage multitasking.
      /// </summary>
      public static UpDownCounter<long> CreateSystemCpuLogicalCount(Meter meter)
      {
          return meter.CreateUpDownCounter<long>("system.cpu.logical.count", "{cpu}", "Reports the number of logical (virtual) processor cores created by the operating system to manage multitasking");
      }

      /// <summary>
      /// Creates <c>system.cpu.physical.count</c> instrument.
      /// Reports the number of actual physical processor cores on the hardware.
      /// </summary>
      public static UpDownCounter<long> CreateSystemCpuPhysicalCount(Meter meter)
      {
          return meter.CreateUpDownCounter<long>("system.cpu.physical.count", "{cpu}", "Reports the number of actual physical processor cores on the hardware");
      }

      /// <summary>
      /// Creates <c>system.cpu.time</c> instrument.
      /// Seconds each logical CPU spent on each mode.
      /// </summary>
      public static Counter<long> CreateSystemCpuTime(Meter meter)
      {
          return meter.CreateCounter<long>("system.cpu.time", "s", "Seconds each logical CPU spent on each mode");
      }

      /// <summary>
      /// Creates <c>system.cpu.utilization</c> instrument.
      /// Difference in system.cpu.time since the last measurement, divided by the elapsed time and number of logical CPUs.
      /// </summary>
      public static ObservableGauge<double> CreateSystemCpuUtilization(Meter meter, Func<Measurement<double>> observe)
      {
          return meter.CreateObservableGauge<double>("system.cpu.utilization", observe, "1", "Difference in system.cpu.time since the last measurement, divided by the elapsed time and number of logical CPUs");
      }

      /// <summary>
      /// Creates <c>system.disk.io</c> instrument.
      /// .
      /// </summary>
      public static Counter<long> CreateSystemDiskIo(Meter meter)
      {
          return meter.CreateCounter<long>("system.disk.io", "By", "");
      }

      /// <summary>
      /// Creates <c>system.disk.io_time</c> instrument.
      /// Time disk spent activated.
      /// </summary>
      /// <remarks>
      /// The real elapsed time (&amp;#34;wall clock&amp;#34;) used in the I/O path (time from operations running in parallel are not counted). Measured as:<ul>
        /// <li>Linux: Field 13 from <a href="https://www.kernel.org/doc/Documentation/ABI/testing/procfs-diskstats">procfs-diskstats</a></li>
        /// <li>Windows: The complement of
        /// <a href="https://learn.microsoft.com/archive/blogs/askcore/windows-performance-monitor-disk-counters-explained#windows-performance-monitor-disk-counters-explained">&amp;#34;Disk% Idle Time&amp;#34;</a>
        /// performance counter: <c>uptime * (100 - &#34;Disk\% Idle Time&#34;) / 100</c></li>
        /// </ul>.
      /// </remarks>
      public static Counter<long> CreateSystemDiskIoTime(Meter meter)
      {
          return meter.CreateCounter<long>("system.disk.io_time", "s", "Time disk spent activated");
      }

      /// <summary>
      /// Creates <c>system.disk.merged</c> instrument.
      /// .
      /// </summary>
      public static Counter<long> CreateSystemDiskMerged(Meter meter)
      {
          return meter.CreateCounter<long>("system.disk.merged", "{operation}", "");
      }

      /// <summary>
      /// Creates <c>system.disk.operation_time</c> instrument.
      /// Sum of the time each operation took to complete.
      /// </summary>
      /// <remarks>
      /// Because it is the sum of time each request took, parallel-issued requests each contribute to make the count grow. Measured as:<ul>
        /// <li>Linux: Fields 7 &amp;amp; 11 from <a href="https://www.kernel.org/doc/Documentation/ABI/testing/procfs-diskstats">procfs-diskstats</a></li>
        /// <li>Windows: &amp;#34;Avg. Disk sec/Read&amp;#34; perf counter multiplied by &amp;#34;Disk Reads/sec&amp;#34; perf counter (similar for Writes)</li>
        /// </ul>.
      /// </remarks>
      public static Counter<long> CreateSystemDiskOperationTime(Meter meter)
      {
          return meter.CreateCounter<long>("system.disk.operation_time", "s", "Sum of the time each operation took to complete");
      }

      /// <summary>
      /// Creates <c>system.disk.operations</c> instrument.
      /// .
      /// </summary>
      public static Counter<long> CreateSystemDiskOperations(Meter meter)
      {
          return meter.CreateCounter<long>("system.disk.operations", "{operation}", "");
      }

      /// <summary>
      /// Creates <c>system.filesystem.usage</c> instrument.
      /// .
      /// </summary>
      public static UpDownCounter<long> CreateSystemFilesystemUsage(Meter meter)
      {
          return meter.CreateUpDownCounter<long>("system.filesystem.usage", "By", "");
      }

      /// <summary>
      /// Creates <c>system.filesystem.utilization</c> instrument.
      /// .
      /// </summary>
      public static ObservableGauge<double> CreateSystemFilesystemUtilization(Meter meter, Func<Measurement<double>> observe)
      {
          return meter.CreateObservableGauge<double>("system.filesystem.utilization", observe, "1", "");
      }

      /// <summary>
      /// Creates <c>system.linux.memory.available</c> instrument.
      /// An estimate of how much memory is available for starting new applications, without causing swapping.
      /// </summary>
      /// <remarks>
      /// This is an alternative to <c>system.memory.usage</c> metric with <c>state=free</c>.
        /// Linux starting from 3.14 exports &amp;#34;available&amp;#34; memory. It takes &amp;#34;free&amp;#34; memory as a baseline, and then factors in kernel-specific values.
        /// This is supposed to be more accurate than just &amp;#34;free&amp;#34; memory.
        /// For reference, see the calculations <a href="https://superuser.com/a/980821">here</a>.
        /// See also <c>MemAvailable</c> in <a href="https://man7.org/linux/man-pages/man5/proc.5.html">/proc/meminfo</a>.
      /// </remarks>
      public static UpDownCounter<long> CreateSystemLinuxMemoryAvailable(Meter meter)
      {
          return meter.CreateUpDownCounter<long>("system.linux.memory.available", "By", "An estimate of how much memory is available for starting new applications, without causing swapping");
      }

      /// <summary>
      /// Creates <c>system.memory.limit</c> instrument.
      /// Total memory available in the system.
      /// </summary>
      /// <remarks>
      /// Its value SHOULD equal the sum of <c>system.memory.state</c> over all states.
      /// </remarks>
      public static UpDownCounter<long> CreateSystemMemoryLimit(Meter meter)
      {
          return meter.CreateUpDownCounter<long>("system.memory.limit", "By", "Total memory available in the system.");
      }

      /// <summary>
      /// Creates <c>system.memory.usage</c> instrument.
      /// Reports memory in use by state.
      /// </summary>
      /// <remarks>
      /// The sum over all <c>system.memory.state</c> values SHOULD equal the total memory
        /// available on the system, that is <c>system.memory.limit</c>.
      /// </remarks>
      public static UpDownCounter<long> CreateSystemMemoryUsage(Meter meter)
      {
          return meter.CreateUpDownCounter<long>("system.memory.usage", "By", "Reports memory in use by state.");
      }

      /// <summary>
      /// Creates <c>system.memory.utilization</c> instrument.
      /// .
      /// </summary>
      public static ObservableGauge<double> CreateSystemMemoryUtilization(Meter meter, Func<Measurement<double>> observe)
      {
          return meter.CreateObservableGauge<double>("system.memory.utilization", observe, "1", "");
      }

      /// <summary>
      /// Creates <c>system.network.connections</c> instrument.
      /// .
      /// </summary>
      public static UpDownCounter<long> CreateSystemNetworkConnections(Meter meter)
      {
          return meter.CreateUpDownCounter<long>("system.network.connections", "{connection}", "");
      }

      /// <summary>
      /// Creates <c>system.network.dropped</c> instrument.
      /// Count of packets that are dropped or discarded even though there was no error.
      /// </summary>
      /// <remarks>
      /// Measured as:<ul>
        /// <li>Linux: the <c>drop</c> column in <c>/proc/dev/net</c> (<a href="https://web.archive.org/web/20180321091318/http://www.onlamp.com/pub/a/linux/2000/11/16/LinuxAdmin.html">source</a>)</li>
        /// <li>Windows: <a href="https://docs.microsoft.com/windows/win32/api/netioapi/ns-netioapi-mib_if_row2"><c>InDiscards</c>/<c>OutDiscards</c></a>
        /// from <a href="https://docs.microsoft.com/windows/win32/api/netioapi/nf-netioapi-getifentry2"><c>GetIfEntry2</c></a></li>
        /// </ul>.
      /// </remarks>
      public static Counter<long> CreateSystemNetworkDropped(Meter meter)
      {
          return meter.CreateCounter<long>("system.network.dropped", "{packet}", "Count of packets that are dropped or discarded even though there was no error");
      }

      /// <summary>
      /// Creates <c>system.network.errors</c> instrument.
      /// Count of network errors detected.
      /// </summary>
      /// <remarks>
      /// Measured as:<ul>
        /// <li>Linux: the <c>errs</c> column in <c>/proc/dev/net</c> (<a href="https://web.archive.org/web/20180321091318/http://www.onlamp.com/pub/a/linux/2000/11/16/LinuxAdmin.html">source</a>).</li>
        /// <li>Windows: <a href="https://docs.microsoft.com/windows/win32/api/netioapi/ns-netioapi-mib_if_row2"><c>InErrors</c>/<c>OutErrors</c></a>
        /// from <a href="https://docs.microsoft.com/windows/win32/api/netioapi/nf-netioapi-getifentry2"><c>GetIfEntry2</c></a></li>
        /// </ul>.
      /// </remarks>
      public static Counter<long> CreateSystemNetworkErrors(Meter meter)
      {
          return meter.CreateCounter<long>("system.network.errors", "{error}", "Count of network errors detected");
      }

      /// <summary>
      /// Creates <c>system.network.io</c> instrument.
      /// .
      /// </summary>
      public static Counter<long> CreateSystemNetworkIo(Meter meter)
      {
          return meter.CreateCounter<long>("system.network.io", "By", "");
      }

      /// <summary>
      /// Creates <c>system.network.packets</c> instrument.
      /// .
      /// </summary>
      public static Counter<long> CreateSystemNetworkPackets(Meter meter)
      {
          return meter.CreateCounter<long>("system.network.packets", "{packet}", "");
      }

      /// <summary>
      /// Creates <c>system.paging.faults</c> instrument.
      /// .
      /// </summary>
      public static Counter<long> CreateSystemPagingFaults(Meter meter)
      {
          return meter.CreateCounter<long>("system.paging.faults", "{fault}", "");
      }

      /// <summary>
      /// Creates <c>system.paging.operations</c> instrument.
      /// .
      /// </summary>
      public static Counter<long> CreateSystemPagingOperations(Meter meter)
      {
          return meter.CreateCounter<long>("system.paging.operations", "{operation}", "");
      }

      /// <summary>
      /// Creates <c>system.paging.usage</c> instrument.
      /// Unix swap or windows pagefile usage.
      /// </summary>
      public static UpDownCounter<long> CreateSystemPagingUsage(Meter meter)
      {
          return meter.CreateUpDownCounter<long>("system.paging.usage", "By", "Unix swap or windows pagefile usage");
      }

      /// <summary>
      /// Creates <c>system.paging.utilization</c> instrument.
      /// .
      /// </summary>
      public static ObservableGauge<double> CreateSystemPagingUtilization(Meter meter, Func<Measurement<double>> observe)
      {
          return meter.CreateObservableGauge<double>("system.paging.utilization", observe, "1", "");
      }

      /// <summary>
      /// Creates <c>system.processes.count</c> instrument.
      /// Total number of processes in each state.
      /// </summary>
      public static UpDownCounter<long> CreateSystemProcessesCount(Meter meter)
      {
          return meter.CreateUpDownCounter<long>("system.processes.count", "{process}", "Total number of processes in each state");
      }

      /// <summary>
      /// Creates <c>system.processes.created</c> instrument.
      /// Total number of processes created over uptime of the host.
      /// </summary>
      public static Counter<long> CreateSystemProcessesCreated(Meter meter)
      {
          return meter.CreateCounter<long>("system.processes.created", "{process}", "Total number of processes created over uptime of the host");
      }
  }
}
